import openpyxl
from collections import defaultdict
import json
import re

def determinar_area(programa):
    """Determina el √°rea de conocimiento basado en el programa"""
    programa_lower = str(programa).lower().strip()
    
    # Econ√≥mico Administrativa
    economico_admin = [
        "administraci√≥n", "negocios", "mercadotecnia", "marketing", "contadur√≠a", 
        "contabilidad", "finanzas", "comercio", "turismo", "hoteler√≠a", 
        "recursos humanos", "econom√≠a", "comercial", "empresarial", "gesti√≥n"
    ]
    
    # Ciencias de la salud
    ciencias_salud = [
        "medicina", "enfermer√≠a", "psicolog√≠a", "nutrici√≥n", "odontolog√≠a", 
        "dentista", "farmacia", "farmac√©utico", "fisioterapia", "terapia", 
        "rehabilitaci√≥n", "optometr√≠a", "veterinaria", "biom√©dica", "salud"
    ]
    
    # Arquitectura y dise√±o
    arquitectura_dise√±o = [
        "arquitectura", "dise√±o", "gr√°fico", "industrial", "interiores", 
        "urbanismo", "planeaci√≥n urbana", "arte", "bellas artes", "visual"
    ]
    
    # Gastronom√≠a
    gastronomia = [
        "gastronom√≠a", "culinaria", "chef", "cocina", "alimentos", "bebidas"
    ]
    
    # Ciencias Sociales y Humanidades
    sociales_humanidades = [
        "derecho", "leyes", "jurisprudencia", "criminolog√≠a", "criminal√≠stica", 
        "trabajo social", "comunicaci√≥n", "periodismo", "filosof√≠a", "historia", 
        "sociolog√≠a", "antropolog√≠a", "geograf√≠a", "educaci√≥n", "pedagog√≠a", 
        "literatura", "idiomas", "lenguas", "relaciones internacionales", 
        "ciencias pol√≠ticas", "humanidades"
    ]
    
    # Ciencias exactas e ingenier√≠as
    exactas_ingenierias = [
        "ingenier√≠a", "sistemas", "inform√°tica", "computaci√≥n", "software", 
        "matem√°ticas", "f√≠sica", "qu√≠mica", "biolog√≠a", "biotecnolog√≠a", 
        "industrial", "civil", "mec√°nica", "el√©ctrica", "electr√≥nica", 
        "telecomunicaciones", "ambiental", "agronom√≠a", "forestal", 
        "ciencias", "tecnolog√≠a", "rob√≥tica", "inteligencia artificial"
    ]
    
    # Buscar coincidencias
    for palabra in economico_admin:
        if palabra in programa_lower:
            return "Econ√≥mico Administrativa"
    
    for palabra in ciencias_salud:
        if palabra in programa_lower:
            return "Ciencias de la salud"
    
    for palabra in arquitectura_dise√±o:
        if palabra in programa_lower:
            return "Arquitectura y dise√±o"
    
    for palabra in gastronomia:
        if palabra in programa_lower:
            return "Gastronom√≠a"
    
    for palabra in sociales_humanidades:
        if palabra in programa_lower:
            return "Ciencias Sociales y Humanidades"
    
    for palabra in exactas_ingenierias:
        if palabra in programa_lower:
            return "Ciencias exactas e ingenier√≠as"
    
    return "Sin clasificar"

def determinar_nivel_educativo(incorporacion, programa):
    """Determina el nivel educativo basado en la incorporaci√≥n y programa"""
    
    if not incorporacion:
        incorporacion = ""
    
    incorporacion_lower = str(incorporacion).lower().strip()
    programa_lower = str(programa).lower().strip()
    
    # NIVELES A OMITIR (retornamos None para que se excluyan)
    
    # BIS - Bachillerato Internacional Escolarizado
    if programa_lower == "bis" or "bis" in programa_lower:
        return None
    
    # Maestr√≠as
    maestrias_palabras = ["maestr√≠a", "maestrias", "master", "mba", "magister", "posgrado"]
    for palabra in maestrias_palabras:
        if palabra in incorporacion_lower or palabra in programa_lower:
            return None
    
    # Bachillerato y niveles b√°sicos
    if any(word in incorporacion_lower or word in programa_lower 
           for word in ["bachillerato", "preparatoria", "high school", "bachiller", 
                       "primaria", "educaci√≥n b√°sica", "elementary",
                       "secundaria", "middle school", "educaci√≥n media"]):
        return None
    
    # Doctorados
    if any(word in incorporacion_lower or word in programa_lower 
           for word in ["doctorado", "phd", "doctor"]):
        return "Doctorados"
    
    # Programas que t√≠picamente son de Educaci√≥n Continua
    educacion_continua_programas = [
        "diplomado", "curso", "certificaci√≥n", "capacitaci√≥n", "continua", 
        "actualizaci√≥n", "especialidad m√©dica", "especializaci√≥n"
    ]
    for patron in educacion_continua_programas:
        if patron in programa_lower or patron in incorporacion_lower:
            return "Educaci√≥n Continua"
    
    # CASOS T√âCNICOS
    if any(word in incorporacion_lower or word in programa_lower 
           for word in ["t√©cnico", "tsu", "profesional asociado", "tecn√≥logo"]):
        return "T√©cnico Superior"
    
    # LICENCIATURAS - Ahora es mucho m√°s inclusivo
    # Excluir solo casos muy espec√≠ficos que NO son licenciaturas
    exclusiones_licenciatura = [
        "diplomado"
    ]
    
    # Si no contiene palabras de exclusi√≥n y tiene m√°s de 3 caracteres, probablemente es licenciatura
    es_exclusion = any(excl in programa_lower or excl in incorporacion_lower 
                      for excl in exclusiones_licenciatura)
    
    if not es_exclusion and len(programa_lower) > 3:
        return "Licenciaturas"
    
    # Por defecto, sin clasificar
    return "Sin Clasificar"

def procesar_hoja_mejorada(ws, nombre_hoja):
    """Procesa una hoja espec√≠fica del archivo Excel con mejor detecci√≥n de estructura"""
    resultados_hoja = defaultdict(list)
    
    plantel_actual = None
    incorporacion_actual = None
    modalidad_actual = None
    
    # Encontrar inicio de los datos
    start_row = None
    for i, row in enumerate(ws.iter_rows(values_only=True), 1):
        if row and len(row) > 0 and row[0] and "Plantel" in str(row[0]):
            start_row = i + 1
            break
    
    if start_row is None:
        print(f"‚ö†Ô∏è  No se encontr√≥ encabezado 'Plantel' en la hoja {nombre_hoja}")
        return resultados_hoja
    
    print(f"üìä Procesando desde la fila {start_row} en {nombre_hoja}")
    
    # Recorrer desde el inicio real
    for i in range(start_row, ws.max_row + 1):
        try:
            row = [cell.value if cell.value is not None else "" for cell in ws[i]]
            
            # Asegurar que tenemos al menos 4 columnas
            while len(row) < 4:
                row.append("")
            
            # Detectar nuevo plantel (columna A) - el plantel se extiende verticalmente
            if row[0] and str(row[0]).strip() and str(row[0]).strip() not in ["Plantel", ""]:
                plantel_candidato = str(row[0]).strip()
                # Verificar que no sea un programa o dato err√≥neo
                if len(plantel_candidato) > 2 and not plantel_candidato.lower() in ['udg', 'sicyt']:
                    plantel_actual = plantel_candidato
                    print(f"üè´ Nuevo plantel detectado: {plantel_actual}")
            
            # Detectar nueva incorporaci√≥n (columna B)
            if row[1] and str(row[1]).strip():
                incorporacion_candidata = str(row[1]).strip()
                # Solo actualizar si parece ser una incorporaci√≥n v√°lida
                if incorporacion_candidata not in ["", "Incorporaci√≥n"] and len(incorporacion_candidata) > 2:
                    incorporacion_actual = incorporacion_candidata
                    print(f"üìú Nueva incorporaci√≥n: {incorporacion_actual}")
            
            # Detectar modalidad (columna D)
            if row[3] and str(row[3]).strip():
                modalidad_candidata = str(row[3]).strip()
                if modalidad_candidata not in ["", "Modalidad"] and len(modalidad_candidata) > 2:
                    modalidad_actual = modalidad_candidata
            
            # Extraer programa (columna C)
            programa = row[2]
            if programa and str(programa).strip() and plantel_actual:
                programa_str = str(programa).strip()
                # Limpiar el programa
                programa_str = ' '.join(programa_str.split())
                
                # Verificar que no sea un encabezado
                if programa_str not in ["Programa", ""] and len(programa_str) > 2:
                    # Determinar nivel educativo y √°rea
                    nivel_educativo = determinar_nivel_educativo(incorporacion_actual, programa_str)
                    
                    # Si el nivel es None (niveles a omitir), saltamos este programa
                    if nivel_educativo is None:
                        print(f"    ‚è≠Ô∏è  Programa omitido: '{programa_str}' (nivel excluido)")
                        continue
                    
                    area = determinar_area(programa_str)
                    
                    # Debug: mostrar clasificaci√≥n para casos problem√°ticos
                    if not incorporacion_actual or incorporacion_actual == "No especificada":
                        print(f"    üîç Programa sin incorporaci√≥n: '{programa_str}' ‚Üí Nivel: {nivel_educativo}, √Årea: {area}")
                    
                    programa_info = {
                        "programa": programa_str,
                        "incorporacion": incorporacion_actual or "No especificada",
                        "modalidad": modalidad_actual or "No especificada",
                        "hoja": nombre_hoja,
                        "nivel_educativo": nivel_educativo,
                        "area": area
                    }
                    
                    resultados_hoja[plantel_actual].append(programa_info)
                    print(f"  üìö Programa agregado: {programa_str} ({nivel_educativo} - {area})")
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error procesando fila {i}: {e}")
            continue
    
    return resultados_hoja

def generar_estructura_educativa(todos_resultados):
    """Genera estructura organizada por nivel educativo > √°rea > programa > plantel"""
    estructura = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(list))))
    
    for plantel, programas in todos_resultados.items():
        if not plantel or str(plantel).strip() == "":
            continue
            
        plantel_limpio = str(plantel).strip()
        
        for programa_info in programas:
            programa = programa_info["programa"]
            nivel = programa_info["nivel_educativo"]
            area = programa_info["area"]
            
            # Saltar programas sin clasificar o niveles excluidos
            if not programa or str(programa).strip() == "" or nivel is None:
                continue
            
            programa_limpio = ' '.join(str(programa).split())
            
            # Evitar duplicados usando una clave √∫nica
            modalidad_incorporacion = f"{programa_info['modalidad']}|{programa_info['incorporacion']}"
            
            # Verificar si ya existe esta combinaci√≥n
            existe = False
            for item in estructura[nivel][area][programa_limpio][plantel_limpio]:
                item_key = f"{item['modalidad']}|{item['incorporacion']}"
                if item_key == modalidad_incorporacion:
                    existe = True
                    break
            
            if not existe:
                estructura[nivel][area][programa_limpio][plantel_limpio].append({
                    "modalidad": programa_info["modalidad"],
                    "incorporacion": programa_info["incorporacion"],
                    "hoja_fuente": programa_info["hoja"]
                })
    
    return estructura

def generar_javascript(estructura_final):
    """Genera el archivo JavaScript con los datos"""
    js_content = """// Datos de programas educativos organizados por nivel, √°rea y plantel
// Generado autom√°ticamente desde datos de Excel

export const programasEducativos = """
    
    # Convertir la estructura a un formato m√°s limpio para JS
    js_data = {}
    for nivel in sorted(estructura_final.keys()):
        js_data[nivel] = {}
        for area in sorted(estructura_final[nivel].keys()):
            js_data[nivel][area] = {}
            for programa in sorted(estructura_final[nivel][area].keys()):
                js_data[nivel][area][programa] = {}
                for plantel in sorted(estructura_final[nivel][area][programa].keys()):
                    js_data[nivel][area][programa][plantel] = estructura_final[nivel][area][programa][plantel]
    
    # Agregar los datos JSON al contenido JS
    js_content += json.dumps(js_data, ensure_ascii=False, indent=2)
    js_content += ";\n\n"
    
    # Agregar funciones de utilidad
    js_content += """
// Funciones de utilidad para consultar los datos

export const areas = [
  "Todas",
  "Econ√≥mico Administrativa",
  "Ciencias de la salud",
  "Arquitectura y dise√±o",
  "Gastronom√≠a",
  "Ciencias Sociales y Humanidades",
  "Ciencias exactas e ingenier√≠as"
];

export const niveles = Object.keys(programasEducativos);

/**
 * Obtiene todos los programas de un nivel educativo espec√≠fico
 * @param {string} nivel - Nivel educativo
 * @returns {Object} Programas del nivel especificado
 */
export function obtenerProgramasPorNivel(nivel) {
  return programasEducativos[nivel] || {};
}

/**
 * Obtiene todos los programas de un √°rea espec√≠fica
 * @param {string} area - √Årea de conocimiento
 * @param {string} nivel - Nivel educativo (opcional)
 * @returns {Object} Programas del √°rea especificada
 */
export function obtenerProgramasPorArea(area, nivel = null) {
  const resultado = {};
  
  if (nivel) {
    return programasEducativos[nivel]?.[area] || {};
  }
  
  for (const nivelKey in programasEducativos) {
    if (programasEducativos[nivelKey][area]) {
      resultado[nivelKey] = programasEducativos[nivelKey][area];
    }
  }
  
  return resultado;
}

/**
 * Busca programas por nombre (b√∫squeda parcial)
 * @param {string} termino - T√©rmino de b√∫squeda
 * @returns {Array} Array de programas que coinciden con el t√©rmino
 */
export function buscarProgramas(termino) {
  const resultados = [];
  const terminoLower = termino.toLowerCase();
  
  for (const nivel in programasEducativos) {
    for (const area in programasEducativos[nivel]) {
      for (const programa in programasEducativos[nivel][area]) {
        if (programa.toLowerCase().includes(terminoLower)) {
          resultados.push({
            programa,
            nivel,
            area,
            planteles: Object.keys(programasEducativos[nivel][area][programa])
          });
        }
      }
    }
  }
  
  return resultados;
}

/**
 * Obtiene informaci√≥n detallada de un programa espec√≠fico
 * @param {string} programa - Nombre del programa
 * @param {string} plantel - Nombre del plantel
 * @returns {Object|null} Informaci√≥n del programa o null si no existe
 */
export function obtenerDetallePrograma(programa, plantel) {
  for (const nivel in programasEducativos) {
    for (const area in programasEducativos[nivel]) {
      if (programasEducativos[nivel][area][programa]?.[plantel]) {
        return {
          programa,
          nivel,
          area,
          plantel,
          detalles: programasEducativos[nivel][area][programa][plantel]
        };
      }
    }
  }
  return null;
}

/**
 * Obtiene estad√≠sticas generales de los datos
 * @returns {Object} Estad√≠sticas de los programas
 */
export function obtenerEstadisticas() {
  let totalProgramas = 0;
  const planteles = new Set();
  const estadisticasPorNivel = {};
  const estadisticasPorArea = {};
  
  for (const nivel in programasEducativos) {
    estadisticasPorNivel[nivel] = 0;
    
    for (const area in programasEducativos[nivel]) {
      if (!estadisticasPorArea[area]) {
        estadisticasPorArea[area] = 0;
      }
      
      for (const programa in programasEducativos[nivel][area]) {
        totalProgramas++;
        estadisticasPorNivel[nivel]++;
        estadisticasPorArea[area]++;
        
        for (const plantel in programasEducativos[nivel][area][programa]) {
          planteles.add(plantel);
        }
      }
    }
  }
  
  return {
    totalProgramas,
    totalPlanteles: planteles.size,
    totalNiveles: Object.keys(programasEducativos).length,
    totalAreas: Object.keys(estadisticasPorArea).length,
    estadisticasPorNivel,
    estadisticasPorArea,
    planteles: Array.from(planteles).sort()
  };
}
"""
    
    return js_content

# EJECUCI√ìN PRINCIPAL
print("üöÄ Iniciando procesamiento del archivo Excel...")

# Cargar el archivo Excel
try:
    wb = openpyxl.load_workbook("oferta2.xlsx")
    print("‚úÖ Archivo Excel cargado correctamente")
except FileNotFoundError:
    print("‚ùå Error: No se encontr√≥ el archivo 'oferta.xlsx'")
    exit(1)

# Nombres de las hojas a procesar
hojas = ["GDL"]

# Diccionario para almacenar todos los resultados
todos_resultados = defaultdict(list)

# Procesar cada hoja
for nombre_hoja in hojas:
    if nombre_hoja in wb.sheetnames:
        print(f"\nüìÑ Procesando hoja: {nombre_hoja}")
        ws = wb[nombre_hoja]
        resultados_hoja = procesar_hoja_mejorada(ws, nombre_hoja)
        
        # Agregar los resultados de esta hoja al diccionario general
        for plantel, programas in resultados_hoja.items():
            todos_resultados[plantel].extend(programas)
            
        print(f"‚úÖ Hoja {nombre_hoja} procesada: {len(resultados_hoja)} planteles encontrados")
    else:
        print(f"‚ö†Ô∏è  Hoja '{nombre_hoja}' no encontrada en el archivo")

# Generar estructura educativa
print("\nüèóÔ∏è  Generando estructura educativa...")
estructura_educativa = generar_estructura_educativa(todos_resultados)

# Convertir a diccionario regular
estructura_final = {}
for nivel in sorted(estructura_educativa.keys()):
    estructura_final[nivel] = {}
    for area in sorted(estructura_educativa[nivel].keys()):
        estructura_final[nivel][area] = {}
        for programa in sorted(estructura_educativa[nivel][area].keys()):
            estructura_final[nivel][area][programa] = {}
            for plantel in sorted(estructura_educativa[nivel][area][programa].keys()):
                estructura_final[nivel][area][programa][plantel] = estructura_educativa[nivel][area][programa][plantel]

# Generar archivo JavaScript
print("\nüì± Generando archivo JavaScript...")
js_content = generar_javascript(estructura_final)

# Guardar archivo JavaScript
with open("programasEducativos.js", "w", encoding="utf-8") as archivo_js:
    archivo_js.write(js_content)

# Mostrar resumen final
print("\nüìä RESUMEN FINAL:")
print("=" * 50)

total_programas = 0
total_planteles = set()
estadisticas_por_area = defaultdict(int)

for nivel in sorted(estructura_final.keys()):
    programas_nivel = 0
    planteles_nivel = set()
    
    for area in estructura_final[nivel]:
        programas_area = len(estructura_final[nivel][area])
        programas_nivel += programas_area
        estadisticas_por_area[area] += programas_area
        
        for programa in estructura_final[nivel][area]:
            for plantel in estructura_final[nivel][area][programa]:
                planteles_nivel.add(plantel)
                total_planteles.add(plantel)
    
    total_programas += programas_nivel
    print(f"\nüéì {nivel}: {programas_nivel} programa{'s' if programas_nivel > 1 else ''}")
    print(f"   üìç Disponible en {len(planteles_nivel)} plantel{'es' if len(planteles_nivel) > 1 else ''}")

print(f"\nüìà ESTAD√çSTICAS POR √ÅREA:")
for area in sorted(estadisticas_por_area.keys()):
    count = estadisticas_por_area[area]
    print(f"   üéØ {area}: {count} programa{'s' if count > 1 else ''}")

print(f"\nüìà TOTALES:")
print(f"   üéì Total de programas √∫nicos: {total_programas}")
print(f"   üè´ Total de planteles √∫nicos: {len(total_planteles)}")
print(f"   üìö Total de niveles educativos: {len(estructura_final)}")
print(f"   üéØ Total de √°reas: {len(estadisticas_por_area)}")

print(f"\n‚úÖ Procesamiento completado!")
print(f"üìÑ Archivo generado:")
print(f"   ‚Ä¢ programasEducativos.js - Datos exportables para JavaScript")

print(f"\nüîç EJEMPLO DE USO EN JAVASCRIPT:")
print(f"import {{ programasEducativos, obtenerProgramasPorArea, buscarProgramas }} from './programasEducativos.js';")
print(f"")
print(f"// Obtener todos los programas de Licenciaturas en Ciencias de la salud")
print(f"const programasSalud = obtenerProgramasPorArea('Ciencias de la salud', 'Licenciaturas');")
print(f"")
print(f"// Buscar programas que contengan 'administraci√≥n'")
print(f"const resultados = buscarProgramas('administraci√≥n');")
print(f"")
print(f"// Acceso directo a los datos")
print(f"const licenciaturas = programasEducativos.Licenciaturas;")

# Mostrar algunos ejemplos de programas encontrados
if "Licenciaturas" in estructura_final:
    print(f"\nüìã ALGUNOS PROGRAMAS DE LICENCIATURA ENCONTRADOS:")
    contador_ejemplos = 0
    for area in estructura_final["Licenciaturas"]:
        if contador_ejemplos >= 15:  # Mostrar m√°ximo 15 ejemplos
            break
        for programa in list(estructura_final["Licenciaturas"][area].keys())[:3]:  # 3 por √°rea
            if contador_ejemplos >= 15:
                break
            planteles_count = len(estructura_final["Licenciaturas"][area][programa])
            print(f"   ‚Ä¢ {programa} ({area}) - {planteles_count} plantel{'es' if planteles_count > 1 else ''}")
            contador_ejemplos += 1
        if contador_ejemplos < 15 and len(estructura_final["Licenciaturas"][area]) > 3:
            restantes = len(estructura_final["Licenciaturas"][area]) - 3
            print(f"   ... y {restantes} programa{'s' if restantes > 1 else ''} m√°s en {area}")
    
    print(f"\nüìä PROGRAMAS INCLUIDOS:")
    total_licenciaturas = sum(len(estructura_final["Licenciaturas"][area]) 
                             for area in estructura_final["Licenciaturas"])
    print(f"   üéì Total de Licenciaturas: {total_licenciaturas}")
    
    for area in sorted(estructura_final["Licenciaturas"].keys()):
        count = len(estructura_final["Licenciaturas"][area])
        print(f"   ‚Ä¢ {area}: {count} programa{'s' if count > 1 else ''}")

print(f"\nüìã NIVELES EXCLUIDOS:")
print(f"   ‚ùå Maestr√≠as")
print(f"   ‚ùå BIS (Bachillerato Internacional)")
print(f"   ‚ùå Bachillerato/Preparatoria")  
print(f"   ‚ùå Secundaria")
print(f"   ‚ùå Primaria")